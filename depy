#!/usr/bin/env bash

set -e

start=`date +%s`

ARG=$1
TARGET=$2
VERBOSE=0
INCREMENTAL=0
BETA=0
DEV=0

for argument in "$@"; do
    case "${argument}" in
        -v|--verbose) VERBOSE=1 ;;
        -i|--incremental) INCREMENTAL=1 ;;
           --beta) BETA=1 ;;
           --dev) DEV=1 ;;
    esac
done

function success {
    echo -e "\033[0;32m$1\033[0m"
}

function error {
    echo -e "\033[0;31m$1\033[0m"
}

function announce {
    local width=${#1}
    local padding=5
    local total=$(($padding+$width+$padding))
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
    printf "\033[$2m%-${padding}.${padding}s"; echo -n $1; printf "\033[$2m%-${padding}.${padding}s\033[0m\n";
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
}

function successBig {
    announce $1 '7;32'
}

function errorBig {
    announce $1 '0;30;41'
}

# Check for dependencies
#
if ! which rsync >/dev/null; then
    error "Cannot find rsync binary"
    exit 1
fi
if ! which ssh >/dev/null; then
    error "Cannot find ssh binary"
    exit 1
fi
if ! which zip >/dev/null; then
    error "Cannot find zip binary"
    exit 1
fi

# Validate Bash version
#
if (( ${BASH_VERSION%%.*} < 4 )); then
    error "Bash 4 or higher is required!"
    exit 1
fi

function getLink() {
    ls -l $1 | awk '{print $11}'
}

function readLinkRecursive() {
    local src tmp

    src=$(getLink $1)

    while true; do
        tmp=$(getLink ${src})
        if [ -z "$tmp" ]; then
            break
        else
            src=$(getLink ${tmp})
        fi
    done

    echo ${src};
}

DEPY_DIR=$(dirname $(readLinkRecursive "$0"))

function showHelp {
    cat ${DEPY_DIR}/help | less
    exit 1
}

# Check if target server argument is passed in
#
function checkInitialization {
    if [ ! -f .depy/config ]; then
        error "Depy configuration not found!"
        error "To initialize Depy run: depy init"
        exit 1
    fi
}

# Check if target server argument is passed in
#
function requireTargetServer {
    local host

    checkInitialization

    if [ -z "$TARGET" ]; then
        error "Missing server name!"
        exit 1
    fi

    declare -A servers
    . .depy/config

    if [ -z "${servers["${TARGET}.host"]}" ]; then
        error "Missing configuration for server ${TARGET}"
        exit 1
    fi
}

# Run each hook in a subprocess
# Prefix the hook with the file name
# Return hook exit status
#
function runHook {
    (. ".depy/hooks/$1" | sed "s/^/[local][$1] /"; return ${PIPESTATUS[0]})
}

# Run remote command without any prefixes or changes
#
function remoteCmdRaw {
    if [ -z "${servers["${TARGET}.host"]}" ]; then
        error "Missing configuration for server \"${TARGET}\""
        exit 1
    fi

    ssh ${servers["${TARGET}.user"]}@${servers["${TARGET}.host"]} -i "${servers["${TARGET}.identity"]}" -p ${servers["${TARGET}.port"]} $@
}

# Run remote command and prefix the output with the target server name
# Also forward the proper return code
#
function remoteCmd {
    local cmd=$1
    local server_release_dir=$2

    if [ -f ".depy/hooks/$cmd" ]; then
        (remoteCmdRaw "bash -s" < ".depy/hooks/${cmd}" "${server_release_dir}" | sed "s/^/[${TARGET}][${cmd}] /"; return ${PIPESTATUS[0]})
    else
        (remoteCmdRaw "cd ${servers["${TARGET}.cwd"]}; $cmd" | sed "s/^/[${TARGET}] /"; return ${PIPESTATUS[0]})
    fi
}

# Generate release name
#
function releaseName {
    echo $(date -u +"%Y%m%d%H%M%S")
}

# Create symbolic link for the current release on the server
#
function link {
    remoteCmd "rm current; ln -s releases/${1} current"
    if [ ${VERBOSE} -eq 1 ]; then
        echo "rm current; ln -s releases/${1} current"
    fi
}

# Create symbolic link from the specified release to current
#
function rollback {
    link "$1"
}

# Pack the local files for release
#
function pack {
    local q=$(if [ ${VERBOSE} -ne 1 ]; then echo "-q"; fi)

    if [ -z "$1" ]; then
        release=$(releaseName)
    else
        release=${1}
    fi

    zip -9 -r ${q} ${ignores[@]/#/--exclude=} --exclude=*.depy/* --exclude=*.DS_Store* "${release}.zip" .
}

function calculateProcessTime() {
    end=`date +%s`
    runtime=$((end-start))
    echo "Finished for ${runtime} seconds"
}

case "${ARG}" in
    init)
        if [ -d .depy ]; then
            error "Depy is already initialized in this directory"
            exit 1
        fi

        mkdir -p .depy/hooks
        cat > .depy/hooks/pre <<EOL
#!/usr/bin/env bash
set -e
echo "Pre hook"
EOL
        cat > .depy/hooks/post <<EOL
#!/usr/bin/env bash
set -e
echo "Post hook"
EOL
        cat > .depy/hooks/remote <<EOL
#!/usr/bin/env bash
set -e
echo "Remote hook"
EOL
        cat > .depy/config <<EOL
servers=(
    [production.host]=192.168.20.20
    [production.port]=22
    [production.user]=ubuntu
    [production.identity]=~/.ssh/id_rsa
    [production.cwd]=/home/ubuntu
)

preHooks=(
    pre
)

remoteHooks=(
    remote
)

postHooks=(
    post
)

# Must match zip --exclude pattern
# https://linux.die.net/man/1/zip
ignores=(
    *.git*
)

shared=(
    logs
)

keepReleases=4
EOL
        success "Done"
    ;;

    setup)
        requireTargetServer
        declare -A servers
        . .depy/config

        if [ -z $(remoteCmdRaw "[ -d \"${servers["${TARGET}.cwd"]}/releases\" ] && echo 1") ]; then
            remoteCmd "mkdir releases"
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${servers["${TARGET}.cwd"]}/shared\" ] && echo 1") ]; then
            remoteCmd "mkdir shared"
        fi
        if [ -z $(remoteCmdRaw "[ -L \"${servers["${TARGET}.cwd"]}/current\" ] && echo 1") ]; then
            remoteCmd "ln -s /dev/null current"
        fi
        if [ -z $(remoteCmdRaw "which unzip") ]; then
            error "Server ${TARGET} does not have unzip installed"
            exit 1
        fi

        calculateProcessTime

        success "Done"
    ;;

    deploy)
        requireTargetServer
        declare -A servers
        . .depy/config

        failed=0
        remoteHooksFailed=0

        # Run pre hooks
        #
        set +e
        for hook in "${preHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error][${hook}] Finished with error exit code"
                failed=1
                break
            fi
        done
        set -e

        # Remote server work
        #
        if [ ${failed} -eq 0 ]; then
            release=$(date -u +"%Y%m%d%H%M%S")
            cwd=${servers["${TARGET}.cwd"]}
            server_dns=${servers["${TARGET}.user"]}@${servers["${TARGET}.host"]}
            server_releases_dir=${servers["${TARGET}.cwd"]}/releases/
            server_release_dir=${server_releases_dir}${release}

            if [ ${INCREMENTAL} -eq 1 ]; then
                latestRelease=$(remoteCmdRaw "cd ${servers["${TARGET}.cwd"]}; ls -1r releases | head -1")
            fi

            if [ -z "${latestRelease}" ]; then
                if [ ${INCREMENTAL} -eq 1 ]; then
                    echo "[${TARGET}] No previous release found. Proceeding as full deploy"
                fi

                echo "[local] Packing files"
                pack ${release}

                echo "[${TARGET}] Transferring packed files"
                rsyncProgress=$(if [ ${VERBOSE} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive ${rsyncProgress} "${release}.zip" -e "ssh -p ${servers["${TARGET}.port"]} -i ${servers["${TARGET}.identity"]}" \
                    ${server_dns}:${server_releases_dir}

                echo "[${TARGET}] Unpacking files"
                unzipQuiet=$(if [ ${VERBOSE} -ne 1 ]; then echo "-q"; fi)
                remoteCmd "unzip ${unzipQuiet} \"releases/${release}.zip\" -d \"releases/${release}\"; rm \"releases/${release}.zip\""
            else
                echo "[${TARGET}] Preparing for incremental deploy"
                remoteCmd "cp -R ${server_releases_dir}${latestRelease} ${server_release_dir}"

                echo "[${TARGET}] Transferring files"
                rsyncProgress=$(if [ ${VERBOSE} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive --delete-after ${rsyncProgress} ${ignores[@]/#/--exclude=} --exclude=.depy --exclude=.DS_Store . \
                    -e "ssh -p ${servers["${TARGET}.port"]} -i ${servers["${TARGET}.identity"]}" ${server_dns}:${server_release_dir}
            fi

            # Setup shared files and folders
            #
            for dir in "${shared[@]}"; do
                if [ -d "${dir}" ] || [ -f "${dir}" ]; then
                    if [ -z $(remoteCmdRaw "[ -d \"${servers["${TARGET}.cwd"]}/shared/${dir}\" ] && echo 1") ]; then
                        remoteCmd "mv \"releases/${release}/${dir}\" \"shared/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    else
                        remoteCmd "rm -rf \"releases/${release}/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    fi
                fi
            done

            # Run remote hooks
            #
            set +e
            for hook in "${remoteHooks[@]}"; do
                remoteCmd ${hook} ${server_release_dir}
                if [ $? -ne 0 ]; then
                    error "[${TARGET}][${hook}] Finished with error exit code"
                    failed=1
                    remoteHooksFailed=1
                    break
                fi
            done
            set -e
        fi

        # Skip if any of the pre or remote hooks failed
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${TARGET}] Linking release as current"
            link "${release}"
        fi

        # Clean up old releases or remove failed release
        #
        if [ ${remoteHooksFailed} -eq 0 ]; then
            echo "[${TARGET}] Clean up old releases"
            remoteCmd "cd ${servers["${TARGET}.cwd"]}/releases; ls | sort -r | sed '1,${keepReleases}d' | xargs rm -rf --"
        else
            echo "[${TARGET}] Remove failed release"
            remoteCmd "cd ${servers["${TARGET}.cwd"]}/releases; ls | sort | tail -n 1 | xargs rm -rf --"
        fi

        # Run post hooks
        #
        set +e
        for hook in "${postHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error][${hook}] Finished with error exit code"
                failed=1
            fi
        done
        set -e

        # Cleaning up local release package
        #
        if [ ${INCREMENTAL} -ne 1 ] && [ -f "${release}.zip" ]; then
            echo "[local] Cleaning up local release package"
            rm "${release}.zip"
            if [ ${VERBOSE} -eq 1 ]; then
                echo "rm ${release}.zip"
            fi
        fi

        calculateProcessTime

        # Announce result of the operation
        #
        echo
        if [ ${failed} -eq 0 ] && [ $? -eq 0 ]; then
            successBig "Success"
        else
            errorBig "Failure"
        fi
        echo
    ;;

    releases)
        requireTargetServer
        declare -A servers
        . .depy/config

        remoteCmdRaw "cd ${servers["${TARGET}.cwd"]}; ls releases"
    ;;

    rollback)
        requireTargetServer
        declare -A servers
        . .depy/config

        release=$3

        if [ ! -z $(remoteCmdRaw "[ -d \"${servers["${TARGET}.cwd"]}/releases/${release}\" ] && echo 1") ]; then
            echo "[${TARGET}] Linking release ${release} as current"
            link "${release}"
        else
            error "[${TARGET}] Release ${release} not found"
        fi
    ;;

    pack)
        checkInitialization
        calculateProcessTime
        pack
    ;;

    update)
        cd ${DEPY_DIR}
        git fetch --tags

        if [ ${DEV} -eq 1 ]; then
            tag="master"
        elif [ ${BETA} -eq 1 ]; then
            tag=$(git tag | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | tail -1)
        else
            tag=$(git tag | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | grep -v "rc" | grep -v "alpha" | grep -v "beta" | tail -1)
        fi

        git checkout ${tag} -q
        success "Switched to version \"${tag}\""
    ;;

    *)
        showHelp
    ;;
esac
