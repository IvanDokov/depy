#!/usr/bin/env bash

cmd=$1
target=$2

function success {
    echo -e "\033[0;32m$1\033[0m"
}

function error {
    echo -e "\033[0;31m$1\033[0m"
}

function announce {
    local width=${#1}
    local padding=5
    local total=$(($padding+$width+$padding))
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
    printf "\033[$2m%-${padding}.${padding}s"; echo -n $1; printf "\033[$2m%-${padding}.${padding}s\033[0m\n";
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
}

function successBig {
    announce $1 '7;32'
}
function errorBig {
    announce $1 '0;30;41'
}

if ! which rsync >/dev/null; then
    error "Cannot find rsync"
    exit 1
fi
if ! which ssh >/dev/null; then
    error "Cannot find ssh"
    exit 1
fi

#
# Validate Bash version
#
if (( ${BASH_VERSION%%.*} < 4 )); then
    error "Bash 4 or higher required!"
    exit 1
fi

function showHelp {
cat <<EOL | less
NAME
    depy

SYNOPSIS
    depy [OPTIONS] [TARGET]

DESCRIPTION
    Depy is a dependency free deployment tool written in BASH. The minimum BASH version required is 4.
    It can work with multiple servers and keep older releases just in case.

    init
        create the required configuration files in .depy directory. This is the only argument which does not require to specify target server.

    setup [TARGET]
        create required directories structure on the remote server.

    deploy [TARGET]
        1) runs pre hooks locally. If any of the hooks fails* the deployment is cancelled and marked as failed
        2) transfer files to the target server
        3) runs remote hooks. If any of the hooks fails* the deployment is cancelled and marked as failed. The failed release will be deleted
        4) linking release to be the current / active release
        5) runs post hooks locally. If any of the hooks fails* the deployment marked as failed, but the deployment is successful and release is not deleted
        * exit with status other than 0

    releases [TARGET]
        list all existing releases on the target server

    rollback [TARGET] [RELEASE]
        rollback to the specified release on the target server
EOL
exit 1
}

#
# Print help
#
if [ -z "$cmd" ]; then
    showHelp
fi


#
# Initialize Depy in current directory if first argument is init
#
if [ "$cmd" == 'init' ]; then
    if [ -d .depy ]; then
        error "Depy is already initialized in this directory"
        exit 1
    fi

    mkdir -p .depy/hooks
    cat > .depy/hooks/pre <<EOL
#!/usr/bin/env bash

echo "Pre hook"
EOL
    cat > .depy/hooks/post <<EOL
#!/usr/bin/env bash

echo "Post hook"
EOL
    cat > .depy/hooks/remote <<EOL
#!/usr/bin/env bash

echo "Remote hook"
EOL
    cat > .depy/config <<EOL
servers=(
    [production.host]=192.168.20.20
    [production.port]=22
    [production.user]=ubuntu
    [production.identity]=~/.ssh/id_rsa
    [production.cwd]=/home/ubuntu
)

preHooks=(
    pre
)

remoteHooks=(
    remote
)

postHooks=(
    post
)

ignores=(
    .git
    .gitignore
)

shared=(
    logs
)

keepReleases=4
EOL
    success "Done"
    exit 0
fi

#
# Load configuration
#
if [ -f .depy/config ]; then
    declare -A servers
    . .depy/config
else
    error "Depy configuration not found!"
    error "To initialize Depy run: depy init"
    exit 1
fi

#
# Run each hook in a subprocess
# Prefix the hook with the file name
# Return hook exit status
#
function runHook {
    (. ".depy/hooks/$1" | sed "s/^/[local][$1] /"; return ${PIPESTATUS[0]})
}

function remoteCmdRaw {
    if [ -z "${servers["${target}.host"]}" ]; then
        error "Missing configuration for server \"${target}\""
        exit 1
    fi

    ssh ${servers["${target}.user"]}@${servers["${target}.host"]} -i "${servers["${target}.identity"]}" -p ${servers["${target}.port"]} $@
}

function remoteCmd {
    local cmd=$1
    local server_release_dir=$2

    if [ -f ".depy/hooks/$cmd" ]; then
        (remoteCmdRaw "bash -s" < ".depy/hooks/${cmd}" "${server_release_dir}" | sed "s/^/[${target}][${cmd}] /"; return ${PIPESTATUS[0]})
    else
        (remoteCmdRaw "cd ${servers["${target}.cwd"]}; $cmd" | sed "s/^/[${target}] /"; return ${PIPESTATUS[0]})
    fi
}

# All commands below require valid $target
if [ -z "$target" ]; then
    error "Missing server name!"
    exit 1
fi

case ${cmd} in
    "setup")
        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/releases\" ] && echo 1") ]; then
            remoteCmd "mkdir releases"
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared\" ] && echo 1") ]; then
            remoteCmd "mkdir shared"
        fi
        if [ -z $(remoteCmdRaw "[ -L \"${servers["${target}.cwd"]}/current\" ] && echo 1") ]; then
            remoteCmd "ln -s /dev/null current"
        fi
        success "Done"
    ;;

    "deploy")
        failed=0

        #
        # Run pre hooks
        #
        for hook in "${preHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error] ${hook}"
                failed=1
                break
            fi
        done

        #
        # Remote server work
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${target}] Transferring files"

            release=$(date -u +"%Y%m%d%H%M%S")
            cwd=${servers["${target}.cwd"]}
            server_dns=${servers["${target}.user"]}@${servers["${target}.host"]}
            server_release_dir=${servers["${target}.cwd"]}/releases/${release}

            rsync --archive --recursive ${ignores[@]/#/--exclude=} --exclude=.depy \
                    ./ -e "ssh -p ${servers["${target}.port"]} -i ${servers["${target}.identity"]}" \
                    ${server_dns}:${server_release_dir}

            #
            # Setup shared files and folders
            #
            for dir in "${shared[@]}"; do
                if [ -d "${dir}" ] || [ -f "${dir}" ]; then
                    if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared/${dir}\" ] && echo 1") ]; then
                        remoteCmd "mv \"releases/${release}/${dir}\" \"shared/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    else
                        remoteCmd "rm -rf \"releases/${release}/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    fi
                fi
            done

            #
            # Run remote hooks
            #
            for hook in "${remoteHooks[@]}"; do
                remoteCmd ${hook} ${server_release_dir}
                if [ $? -ne 0 ]; then
                    error "[${target}][${hook}] Finished with exit code different than 0"
                    failed=1
                    break
                fi
            done
        fi

        #
        # Skip if any of the pre or remote hooks failed
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${target}] Linking release as current"
            remoteCmd "rm current; ln -s releases/${release} current"
        fi

        #
        # Run post hooks
        #
        for hook in "${postHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                failed=1
            fi
        done

        #
        # Clean up old releases
        #
        remoteCmd "cd ${servers["${target}.cwd"]}/releases; ls | sort -r | sed '1,${keepReleases}d' | xargs rm -rf --"

        #
        # Announce result of the operation
        #
        echo
        if [ ${failed} -eq 0 ] && [ $? -eq 0 ]; then
            successBig "Success"
        else
            errorBig "Failure"
        fi
        echo
        ;;

    "releases")
        remoteCmdRaw "cd ${servers["${target}.cwd"]}; ls releases"
    ;;

    *) showHelp;;
esac