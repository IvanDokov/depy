#!/usr/bin/env bash

set -e

start=`date +%s`

arg=$1
target=$2
verbose=0
incremental=0

for argument in "$@"; do
    case "${argument}" in
        -v|--verbose) verbose=1 ;;
        -i|--incremental) incremental=1 ;;
    esac
done

function success {
    echo -e "\033[0;32m$1\033[0m"
}

function error {
    echo -e "\033[0;31m$1\033[0m"
}

function announce {
    local width=${#1}
    local padding=5
    local total=$(($padding+$width+$padding))
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
    printf "\033[$2m%-${padding}.${padding}s"; echo -n $1; printf "\033[$2m%-${padding}.${padding}s\033[0m\n";
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
}

function successBig {
    announce $1 '7;32'
}
function errorBig {
    announce $1 '0;30;41'
}

# Check for dependencies
#
if ! which rsync >/dev/null; then
    error "Cannot find rsync binary"
    exit 1
fi
if ! which ssh >/dev/null; then
    error "Cannot find ssh binary"
    exit 1
fi
if ! which zip >/dev/null; then
    error "Cannot find zip binary"
    exit 1
fi

# Validate Bash version
#
if (( ${BASH_VERSION%%.*} < 4 )); then
    error "Bash 4 or higher is required!"
    exit 1
fi

function showHelp {
    cat <<EOL | less
NAME
    depy

SYNOPSIS
    depy [ARGUMENT] [TARGET]

DESCRIPTION
    Depy is a dependency free deployment tool written in BASH. The minimum BASH version required is 4.
    It can work with multiple servers and keep older releases just in case.

ARGUMENTS
    init
        create the required configuration files in .depy directory. This is the only argument which does not require to specify target server.

    setup [TARGET]
        create required directories structure on the remote server.

    deploy [TARGET]
        1) runs pre hooks locally. If any of the hooks fails* the deployment is cancelled and marked as failed
        2) transfer files to the target server
        3) runs remote hooks. If any of the hooks fails* the deployment is cancelled and marked as failed. The failed release will be deleted
        4) linking release to be the current / active release
        5) clean up old releases on the target server
        6) runs post hooks locally. If any of the hooks fails* the deployment marked as failed, but the deployment is successful and release is not deleted
        * exit with status other than 0

        -i|--incremental flag will change the deployment process. It will duplicate the latest release on the server and upload only the changes. This will decrease the deployment time

    releases [TARGET]
        list all existing releases on the target server

    rollback [TARGET] [RELEASE]
        rollback to the specified release on the target server

    pack
        create package with the files to be deployed. This can be used for manual deployment
EOL
    exit 1
}

# Check if target server argument is passed in
#
function checkInitialization {
    if [ ! -f .depy/config ]; then
        error "Depy configuration not found!"
        error "To initialize Depy run: depy init"
        exit 1
    fi
}

# Check if target server argument is passed in
#
function requireTargetServer {
    local host

    checkInitialization

    if [ -z "$target" ]; then
        error "Missing server name!"
        exit 1
    fi

    declare -A servers
    . .depy/config

    if [ -z "${servers["${target}.host"]}" ]; then
        error "Missing configuration for server ${target}"
        exit 1
    fi
}

# Run each hook in a subprocess
# Prefix the hook with the file name
# Return hook exit status
#
function runHook {
    (. ".depy/hooks/$1" | sed "s/^/[local][$1] /"; return ${PIPESTATUS[0]})
}

# Run remote command without any prefixes or changes
#
function remoteCmdRaw {
    if [ -z "${servers["${target}.host"]}" ]; then
        error "Missing configuration for server \"${target}\""
        exit 1
    fi

    ssh ${servers["${target}.user"]}@${servers["${target}.host"]} -i "${servers["${target}.identity"]}" -p ${servers["${target}.port"]} $@
}

# Run remote command and prefix the output with the target server name
# Also forward the proper return code
#
function remoteCmd {
    local cmd=$1
    local server_release_dir=$2

    if [ -f ".depy/hooks/$cmd" ]; then
        (remoteCmdRaw "bash -s" < ".depy/hooks/${cmd}" "${server_release_dir}" | sed "s/^/[${target}][${cmd}] /"; return ${PIPESTATUS[0]})
    else
        (remoteCmdRaw "cd ${servers["${target}.cwd"]}; $cmd" | sed "s/^/[${target}] /"; return ${PIPESTATUS[0]})
    fi
}

# Generate release name
#
function releaseName {
    echo $(date -u +"%Y%m%d%H%M%S")
}

# Create symbolic link for the current release on the server
#
function link {
    remoteCmd "rm current; ln -s releases/${1} current"
    if [ ${verbose} -eq 1 ]; then
        echo "rm current; ln -s releases/${1} current"
    fi
}

# Create symbolic link from the specified release to current
#
function rollback {
    link "$1"
}

# Pack the local files for release
#
function pack {
    local q=$(if [ ${verbose} -ne 1 ]; then echo "-q"; fi)

    if [ -z "$1" ]; then
        release=$(releaseName)
    else
        release=${1}
    fi

    zip -9 -r ${q} ${ignores[@]/#/--exclude=} --exclude=*.depy/* --exclude=*.DS_Store* "${release}.zip" .
}

function readlink() {
    ls -l $1 | awk '{print $11}'
}

function readlinkRecursive() {
    local src tmp

    src=$(readlink $1)

    while true; do
        tmp=$(readlink $src)
        if [ -z "$tmp" ]; then
            break
        else
            src=$(readlink $tmp)
        fi
    done

    echo $src;
}

function calculateProcessTime() {
    end=`date +%s`
    runtime=$((end-start))
    echo "Finished for ${runtime} seconds"
}

case "${arg}" in
    init)
        if [ -d .depy ]; then
            error "Depy is already initialized in this directory"
            exit 1
        fi

        mkdir -p .depy/hooks
        cat > .depy/hooks/pre <<EOL
#!/usr/bin/env bash
set -e
echo "Pre hook"
EOL
        cat > .depy/hooks/post <<EOL
#!/usr/bin/env bash
set -e
echo "Post hook"
EOL
        cat > .depy/hooks/remote <<EOL
#!/usr/bin/env bash
set -e
echo "Remote hook"
EOL
        cat > .depy/config <<EOL
servers=(
    [production.host]=192.168.20.20
    [production.port]=22
    [production.user]=ubuntu
    [production.identity]=~/.ssh/id_rsa
    [production.cwd]=/home/ubuntu
)

preHooks=(
    pre
)

remoteHooks=(
    remote
)

postHooks=(
    post
)

# Must match zip --exclude pattern
# https://linux.die.net/man/1/zip
ignores=(
    *.git*
)

shared=(
    logs
)

keepReleases=4
EOL
        success "Done"
    ;;

    setup)
        requireTargetServer
        declare -A servers
        . .depy/config

        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/releases\" ] && echo 1") ]; then
            remoteCmd "mkdir releases"
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared\" ] && echo 1") ]; then
            remoteCmd "mkdir shared"
        fi
        if [ -z $(remoteCmdRaw "[ -L \"${servers["${target}.cwd"]}/current\" ] && echo 1") ]; then
            remoteCmd "ln -s /dev/null current"
        fi
        if [ -z $(remoteCmdRaw "which unzip") ]; then
            error "Server ${target} does not have unzip installed"
            exit 1
        fi

        calculateProcessTime

        success "Done"
    ;;

    deploy)
        requireTargetServer
        declare -A servers
        . .depy/config

        failed=0
        remoteHooksFailed=0

        # Run pre hooks
        #
        set +e
        for hook in "${preHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error][${hook}] Finished with error exit code"
                failed=1
                break
            fi
        done
        set -e

        # Remote server work
        #
        if [ ${failed} -eq 0 ]; then
            release=$(date -u +"%Y%m%d%H%M%S")
            cwd=${servers["${target}.cwd"]}
            server_dns=${servers["${target}.user"]}@${servers["${target}.host"]}
            server_releases_dir=${servers["${target}.cwd"]}/releases/
            server_release_dir=${server_releases_dir}${release}

            if [ ${incremental} -eq 1 ]; then
                latestRelease=$(remoteCmdRaw "cd ${servers["${target}.cwd"]}; ls -1r releases | head -1")
            fi

            if [ -z "${latestRelease}" ]; then
                if [ ${incremental} -eq 1 ]; then
                    echo "[${target}] No previous release found. Proceeding as full deploy"
                fi

                echo "[local] Packing files"
                pack ${release}

                echo "[${target}] Transferring packed files"
                rsyncProgress=$(if [ ${verbose} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive ${rsyncProgress} "${release}.zip" -e "ssh -p ${servers["${target}.port"]} -i ${servers["${target}.identity"]}" \
                    ${server_dns}:${server_releases_dir}

                echo "[${target}] Unpacking files"
                unzipQuiet=$(if [ ${verbose} -ne 1 ]; then echo "-q"; fi)
                remoteCmd "unzip ${unzipQuiet} \"releases/${release}.zip\" -d \"releases/${release}\"; rm \"releases/${release}.zip\""
            else
                echo "[${target}] Preparing for incremental deploy"
                remoteCmd "cp -R ${server_releases_dir}${latestRelease} ${server_release_dir}"

                echo "[${target}] Transferring files"
                rsyncProgress=$(if [ ${verbose} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive --delete-after ${rsyncProgress} ${ignores[@]/#/--exclude=} --exclude=.depy --exclude=.DS_Store . \
                    -e "ssh -p ${servers["${target}.port"]} -i ${servers["${target}.identity"]}" ${server_dns}:${server_release_dir}
            fi

            # Setup shared files and folders
            #
            for dir in "${shared[@]}"; do
                if [ -d "${dir}" ] || [ -f "${dir}" ]; then
                    if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared/${dir}\" ] && echo 1") ]; then
                        remoteCmd "mv \"releases/${release}/${dir}\" \"shared/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    else
                        remoteCmd "rm -rf \"releases/${release}/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    fi
                fi
            done

            # Run remote hooks
            #
            set +e
            for hook in "${remoteHooks[@]}"; do
                remoteCmd ${hook} ${server_release_dir}
                if [ $? -ne 0 ]; then
                    error "[${target}][${hook}] Finished with error exit code"
                    failed=1
                    remoteHooksFailed=1
                    break
                fi
            done
            set -e
        fi

        # Skip if any of the pre or remote hooks failed
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${target}] Linking release as current"
            link "${release}"
        fi

        # Clean up old releases or remove failed release
        #
        if [ ${remoteHooksFailed} -eq 0 ]; then
            echo "[${target}] Clean up old releases"
            remoteCmd "cd ${servers["${target}.cwd"]}/releases; ls | sort -r | sed '1,${keepReleases}d' | xargs rm -rf --"
        else
            echo "[${target}] Remove failed release"
            remoteCmd "cd ${servers["${target}.cwd"]}/releases; ls | sort | tail -n 1 | xargs rm -rf --"
        fi

        # Run post hooks
        #
        set +e
        for hook in "${postHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error][${hook}] Finished with error exit code"
                failed=1
            fi
        done
        set -e

        # Cleaning up local release package
        #
        if [ ${incremental} -ne 1 ] && [ -f "${release}.zip" ]; then
            echo "[local] Cleaning up local release package"
            rm "${release}.zip"
            if [ ${verbose} -eq 1 ]; then
                echo "rm ${release}.zip"
            fi
        fi

        calculateProcessTime

        # Announce result of the operation
        #
        echo
        if [ ${failed} -eq 0 ] && [ $? -eq 0 ]; then
            successBig "Success"
        else
            errorBig "Failure"
        fi
        echo
    ;;

    releases)
        requireTargetServer
        declare -A servers
        . .depy/config

        remoteCmdRaw "cd ${servers["${target}.cwd"]}; ls releases"
    ;;

    rollback)
        requireTargetServer
        declare -A servers
        . .depy/config

        release=$3

        if [ ! -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/releases/${release}\" ] && echo 1") ]; then
            echo "[${target}] Linking release ${release} as current"
            link "${release}"
        else
            error "[${target}] Release ${release} not found"
        fi
    ;;

    pack)
        checkInitialization
        calculateProcessTime
        pack
    ;;

    update)
        self=$(readlinkRecursive "$0")
        dir=$(dirname ${self})
        cd $dir
        git fetch --tags
        tag=$(git tag | sort -V | grep -v "rc" | grep -v "alpha" | grep -v "beta" | tail -1)
        git checkout ${tag}
        success "Done"
    ;;

    *)
        showHelp
    ;;
esac
