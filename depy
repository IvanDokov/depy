#!/usr/bin/env bash

set -e

arg=$1
target=$2
verbose=0
incremental=0

for argument in "$@"; do
    case "${argument}" in
        -v|--verbose) verbose=1 ;;
        -i|--incremental) incremental=1 ;;
    esac
done

function success {
    echo -e "\033[0;32m$1\033[0m"
}

function error {
    echo -e "\033[0;31m$1\033[0m"
}

function announce {
    local width=${#1}
    local padding=5
    local total=$(($padding+$width+$padding))
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
    printf "\033[$2m%-${padding}.${padding}s"; echo -n $1; printf "\033[$2m%-${padding}.${padding}s\033[0m\n";
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
}

function successBig {
    announce $1 '7;32'
}
function errorBig {
    announce $1 '0;30;41'
}

# Check for dependencies
#
if ! which rsync >/dev/null; then
    error "Cannot find rsync binary"
    exit 1
fi
if ! which ssh >/dev/null; then
    error "Cannot find ssh binary"
    exit 1
fi
if ! which zip >/dev/null; then
    error "Cannot find zip binary"
    exit 1
fi

# Validate Bash version
#
if (( ${BASH_VERSION%%.*} < 4 )); then
    error "Bash 4 or higher required!"
    exit 1
fi

function showHelp {
    cat <<EOL | less -X
NAME
    depy

SYNOPSIS
    depy [ARGUMENT] [TARGET]

DESCRIPTION
    Depy is a dependency free deployment tool written in BASH. The minimum BASH version required is 4.
    It can work with multiple servers and keep older releases just in case.

ARGUMENTS
    init
        create the required configuration files in .depy directory. This is the only argument which does not require to specify target server.

    setup [TARGET]
        create required directories structure on the remote server.

    deploy [TARGET]
        1) runs pre hooks locally. If any of the hooks fails* the deployment is cancelled and marked as failed
        2) transfer files to the target server
        3) runs remote hooks. If any of the hooks fails* the deployment is cancelled and marked as failed. The failed release will be deleted
        4) linking release to be the current / active release
        5) clean up old releases on the target server
        6) runs post hooks locally. If any of the hooks fails* the deployment marked as failed, but the deployment is successful and release is not deleted
        * exit with status other than 0

    releases [TARGET]
        list all existing releases on the target server

    rollback [TARGET] [RELEASE]
        rollback to the specified release on the target server

    pack
        create package with the files to be deployed. This can be used for manual deployment
EOL
    exit 1
}

# Check if target server argument is passed in
#
function requireTargetServer {
    if [ -z "$target" ]; then
        error "Missing server name!"
        exit 1
    fi
}

# Run each hook in a subprocess
# Prefix the hook with the file name
# Return hook exit status
#
function runHook {
    (. ".depy/hooks/$1" | sed "s/^/[local][$1] /"; return ${PIPESTATUS[0]})
}

# Run remote command without any prefixes or changes
#
function remoteCmdRaw {
    if [ -z "${servers["${target}.host"]}" ]; then
        error "Missing configuration for server \"${target}\""
        exit 1
    fi

    ssh ${servers["${target}.user"]}@${servers["${target}.host"]} -i "${servers["${target}.identity"]}" -p ${servers["${target}.port"]} $@
}

# Run remote command and prefix the output with the target server name
# Also forward the proper return code
#
function remoteCmd {
    local cmd=$1
    local server_release_dir=$2

    if [ -f ".depy/hooks/$cmd" ]; then
        (remoteCmdRaw "bash -s" < ".depy/hooks/${cmd}" "${server_release_dir}" | sed "s/^/[${target}][${cmd}] /"; return ${PIPESTATUS[0]})
    else
        (remoteCmdRaw "cd ${servers["${target}.cwd"]}; $cmd" | sed "s/^/[${target}] /"; return ${PIPESTATUS[0]})
    fi
}

# Generate release name
#
function releaseName {
    echo $(date -u +"%Y%m%d%H%M%S")
}

# Create symbolic link for the current release on the server
#
function link {
    remoteCmd "rm current; ln -s releases/${1} current"
    if [ ${verbose} -eq 1 ]; then
        echo "rm current; ln -s releases/${1} current"
    fi
}

# Create symbolic link from the specified release to current
#
function rollback {
    link "$1"
}

# Pack the local files for release
#
function pack {
    local q=$(if [ ${verbose} -ne 1 ]; then echo "-q"; fi)

    if [ -z "$1" ]; then
        release=$(releaseName)
    else
        release=${1}
    fi

    zip -9 -r ${q} ${ignores[@]/#/--exclude=} --exclude=*.depy/* --exclude=*.DS_Store* "${release}.zip" .
}

case "${arg}" in
    init)
        if [ -d .depy ]; then
            error "Depy is already initialized in this directory"
            exit 1
        fi

        mkdir -p .depy/hooks
        cat > .depy/hooks/pre <<EOL
#!/usr/bin/env bash

echo "Pre hook"
EOL
        cat > .depy/hooks/post <<EOL
#!/usr/bin/env bash

echo "Post hook"
EOL
        cat > .depy/hooks/remote <<EOL
#!/usr/bin/env bash

echo "Remote hook"
EOL
        cat > .depy/config <<EOL
servers=(
    [production.host]=192.168.20.20
    [production.port]=22
    [production.user]=ubuntu
    [production.identity]=~/.ssh/id_rsa
    [production.cwd]=/home/ubuntu
)

preHooks=(
    pre
)

remoteHooks=(
    remote
)

postHooks=(
    post
)

# Must match zip --exclude pattern
# https://linux.die.net/man/1/zip
ignores=(
    *.git*
)

shared=(
    logs
)

keepReleases=4
EOL
        success "Done"
    ;;

    setup)
        if [ -f .depy/config ]; then
            declare -A servers
            . .depy/config
        else
            error "Depy configuration not found!"
            error "To initialize Depy run: depy init"
            exit 1
        fi
        requireTargetServer

        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/releases\" ] && echo 1") ]; then
            remoteCmd "mkdir releases"
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared\" ] && echo 1") ]; then
            remoteCmd "mkdir shared"
        fi
        if [ -z $(remoteCmdRaw "[ -L \"${servers["${target}.cwd"]}/current\" ] && echo 1") ]; then
            remoteCmd "ln -s /dev/null current"
        fi
        success "Done"
    ;;

    deploy)
        if [ -f .depy/config ]; then
            declare -A servers
            . .depy/config
        else
            error "Depy configuration not found!"
            error "To initialize Depy run: depy init"
            exit 1
        fi
        requireTargetServer

        failed=0
        remoteHooksFailed=0

        #
        # Run pre hooks
        #
        for hook in "${preHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                error "[error] ${hook}"
                failed=1
                break
            fi
        done

        #
        # Remote server work
        #
        if [ ${failed} -eq 0 ]; then
            release=$(date -u +"%Y%m%d%H%M%S")
            cwd=${servers["${target}.cwd"]}
            server_dns=${servers["${target}.user"]}@${servers["${target}.host"]}
            server_releases_dir=${servers["${target}.cwd"]}/releases/
            server_release_dir=${server_releases_dir}${release}

            if [ ${incremental} -eq 1 ]; then
                latestRelease=$(remoteCmdRaw "cd ${servers["${target}.cwd"]}; ls -1r releases | head -1")
            fi

            if [ -z "${latestRelease}" ]; then
                if [ ${incremental} -eq 1 ]; then
                    echo "[${target}] No previous release found. Proceeding as full deploy"
                fi

                echo "[${target}] Packing files"
                pack ${release}

                echo "[${target}] Transferring packed files"
                rsyncProgress=$(if [ ${verbose} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive ${rsyncProgress} "${release}.zip" -e "ssh -p ${servers["${target}.port"]} -i ${servers["${target}.identity"]}" \
                    ${server_dns}:${server_releases_dir}

                echo "[${target}] Unpacking files"
                unzipQuiet=$(if [ ${verbose} -ne 1 ]; then echo "-q"; fi)
                remoteCmd "unzip ${unzipQuiet} \"releases/${release}.zip\" -d \"releases/${release}\"; rm \"releases/${release}.zip\""

                echo "[${target}] Cleaning up packed files"
                rm "${release}.zip"
                if [ ${verbose} -eq 1 ]; then
                    echo "rm ${release}.zip"
                fi
            else
                echo "[${target}] Preparing for incremental deploy"
                remoteCmd "cp -R ${server_releases_dir}${latestRelease} ${server_release_dir}"

                echo "[${target}] Transferring files"
                rsyncProgress=$(if [ ${verbose} -eq 1 ]; then echo "--progress"; fi)
                rsync --archive ${rsyncProgress} ${ignores[@]/#/--exclude=} --exclude=.depy --exclude=.DS_Store . \
                    -e "ssh -p ${servers["${target}.port"]} -i ${servers["${target}.identity"]}" ${server_dns}:${server_release_dir}
            fi

            #
            # Setup shared files and folders
            #
            for dir in "${shared[@]}"; do
                if [ -d "${dir}" ] || [ -f "${dir}" ]; then
                    if [ -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/shared/${dir}\" ] && echo 1") ]; then
                        remoteCmd "mv \"releases/${release}/${dir}\" \"shared/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    else
                        remoteCmd "rm -rf \"releases/${release}/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    fi
                fi
            done

            #
            # Run remote hooks
            #
            for hook in "${remoteHooks[@]}"; do
                remoteCmd ${hook} ${server_release_dir}
                if [ $? -ne 0 ]; then
                    error "[${target}][${hook}] Finished with exit code different than 0"
                    failed=1
                    remoteHooksFailed=1
                    break
                fi
            done
        fi

        #
        # Skip if any of the pre or remote hooks failed
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${target}] Linking release as current"
            link "${release}"
        fi

        #
        # Clean up old releases or remove failed release
        #
        if [ ${remoteHooksFailed} -eq 0 ]; then
            remoteCmd "cd ${servers["${target}.cwd"]}/releases; ls | sort -r | sed '1,${keepReleases}d' | xargs rm -rf --"
        else
            remoteCmd "cd ${servers["${target}.cwd"]}/releases; ls | sort | tail -n 1 | xargs rm -rf --"
        fi

        #
        # Run post hooks
        #
        for hook in "${postHooks[@]}"; do
            runHook ${hook}
            if [ $? -ne 0 ]; then
                failed=1
            fi
        done

        #
        # Announce result of the operation
        #
        echo
        if [ ${failed} -eq 0 ] && [ $? -eq 0 ]; then
            successBig "Success"
        else
            errorBig "Failure"
        fi
        echo
    ;;

    releases)
        if [ -f .depy/config ]; then
            declare -A servers
            . .depy/config
        else
            error "Depy configuration not found!"
            error "To initialize Depy run: depy init"
            exit 1
        fi
        requireTargetServer
        remoteCmdRaw "cd ${servers["${target}.cwd"]}; ls releases"
    ;;

    rollback)
        if [ -f .depy/config ]; then
            declare -A servers
            . .depy/config
        else
            error "Depy configuration not found!"
            error "To initialize Depy run: depy init"
            exit 1
        fi
        requireTargetServer
        release=$3

        if [ ! -z $(remoteCmdRaw "[ -d \"${servers["${target}.cwd"]}/releases/${release}\" ] && echo 1") ]; then
            echo "[${target}] Linking release ${release} as current"
            link "${release}"
        else
            error "[${target}] Release ${release} not found"
        fi
    ;;

    pack)
        if [ -f .depy/config ]; then
            declare -A servers
            . .depy/config
        else
            error "Depy configuration not found!"
            error "To initialize Depy run: depy init"
            exit 1
        fi
        pack
    ;;

    *)
        showHelp
    ;;
esac