#!/usr/bin/env bash

set -e

start=`date +%s`

PROJECT_DEPY_DIR=depy

ARG=$1
TARGET=$2
VERBOSE=0
INCREMENTAL=0
BETA=0
DEV=0
INTERNAL_IGNORE=(
    "*depy/*"
    "*.idea*"
    "*.git*"
    "*.DS_Store*"
    "*.fuse_hidden*"
    "*.directory*"
    "*.Trash-*"
    "*.nfs*"
)

for argument in "$@"; do
    case "${argument}" in
        -v|--verbose) VERBOSE=1 ;;
        -i|--incremental) INCREMENTAL=1 ;;
           --beta) BETA=1 ;;
           --dev) DEV=1 ;;
    esac
done

function success {
    echo -e "\033[0;32m$1\033[0m"
}

function error {
    echo -e "\033[0;31m$1\033[0m"
}

function announce {
    local width=${#1}
    local padding=5
    local total=$(($padding+$width+$padding))
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
    printf "\033[$2m%-${padding}.${padding}s"; echo -n $1; printf "\033[$2m%-${padding}.${padding}s\033[0m\n";
    printf "\033[$2m%-${total}.${total}s\033[0m\n"
}

function successBig {
    announce $1 '7;32'
}

function errorBig {
    announce $1 '0;30;41'
}

# Check for dependencies
#
if ! which rsync >/dev/null; then
    error "Cannot find rsync binary"
    exit 1
fi
if ! which ssh >/dev/null; then
    error "Cannot find ssh binary"
    exit 1
fi
if ! which zip >/dev/null; then
    error "Cannot find zip binary"
    exit 1
fi

function getLink() {
    ls -l $1 | awk '{print $11}'
}

function readLinkRecursive() {
    local src tmp

    src=$(getLink $1)

    while true; do
        tmp=$(getLink ${src})
        if [ -z "$tmp" ]; then
            break
        else
            src=$(getLink ${tmp})
        fi
    done

    echo ${src};
}

DEPY_DIR=$(dirname $(readLinkRecursive "$0"))

function showHelp {
    cat ${DEPY_DIR}/help | less
    exit 1
}

# Check if target server argument is passed in
#
function checkInitialization {
    if [ ! -f ${PROJECT_DEPY_DIR}/config ]; then
        error "Depy configuration not found!"
        error "To initialize Depy run: depy init"
        exit 1
    fi
}

# Load configurations
#
function loadConfig {
    checkInitialization

    . ${PROJECT_DEPY_DIR}/config
}

# Load and validate configuration for target server
#
function loadConfigForServer {
    if [ -z "$TARGET" ]; then
        error "Missing server name!"
        exit 1
    fi

    loadConfig

    SERVER_HOST="${TARGET}_host"
    if [ -z "${!SERVER_HOST}" ]; then
        error "Missing host for server ${TARGET}"
        exit 1
    fi

    SERVER_PORT="${TARGET}_port"
    if [ -z "${!SERVER_PORT}" ]; then
        error "Missing port for server ${TARGET}"
        exit 1
    fi

    SERVER_USER="${TARGET}_user"
    if [ -z "${!SERVER_USER}" ]; then
        error "Missing user for server ${TARGET}"
        exit 1
    fi

    SERVER_IDENTITY="${TARGET}_identity"
    if [ -z "${!SERVER_IDENTITY}" ]; then
        error "Missing identity file for server ${TARGET}"
        exit 1
    fi

    SERVER_CWD="${TARGET}_cwd"
    if [ -z "${!SERVER_CWD}" ]; then
        error "Missing cwd for server ${TARGET}"
        exit 1
    fi

    SERVER_HOST="${!SERVER_HOST}"
    SERVER_PORT="${!SERVER_PORT}"
    SERVER_USER="${!SERVER_USER}"
    SERVER_IDENTITY="${!SERVER_IDENTITY}"
    SERVER_CWD="${!SERVER_CWD}"
}

# Run each hook in a subprocess
# Prefix the hook with the file name
# Return hook exit status
#
function runHook {
    (. "${PROJECT_DEPY_DIR}/hooks/$1" "$2" ${INCREMENTAL} | sed "s/^/[local][$1] /"; return ${PIPESTATUS[0]})
}

# Run remote command without any prefixes or changes
#
function remoteCmdRaw {
    ssh ${SERVER_USER}@${SERVER_HOST} -i "${SERVER_IDENTITY}" -p ${SERVER_PORT} $@
}

# Run remote command and prefix the output with the target server name
# Also forward the proper return code
#
function remoteCmd {
    local cmd=$1
    local server_release_dir=$2

    if [ -f "${PROJECT_DEPY_DIR}/hooks/$cmd" ]; then
        (remoteCmdRaw "bash -s" < "${PROJECT_DEPY_DIR}/hooks/${cmd}" "${server_release_dir}" ${INCREMENTAL} | sed "s/^/[${TARGET}][${cmd}] /"; return ${PIPESTATUS[0]})
    else
        (remoteCmdRaw "cd ${SERVER_CWD}; $cmd" | sed "s/^/[${TARGET}] /"; return ${PIPESTATUS[0]})
    fi
}

# Generate release name
#
function releaseName {
    echo $(date -u +"%Y%m%d%H%M%S")
}

# Create symbolic link for the current release on the server
#
function link {
    remoteCmd "rm current; ln -s releases/${1} current"
    if [ ${VERBOSE} -eq 1 ]; then
        echo "rm current; ln -s releases/${1} current"
    fi
}

# Create symbolic link from the specified release to current
#
function rollback {
    link "$1"
}

# Shortcut for zip command
#
function zipCommand {
    local q=$(if [ ${VERBOSE} -ne 1 ]; then echo "-q"; fi)

    if [ ${VERBOSE} -eq 1 ]; then set -x; fi
    zip -9 -r -y ${q} ${ignores[@]/#/--exclude=} ${INTERNAL_IGNORE[@]/#/--exclude=} "$@"
    set +x
}

# Pack the local files for release
#
function pack {
    if [ -z "$1" ]; then release=$(releaseName); else release=${1}; fi
    if [ -z "$2" ]; then path=''; else path="${2%/}/"; fi

    if [ -z "$3" ]; then
        zipCommand "${path}${release}.zip" .
    else
        zipCommand "${path}${3}.zip" . -DF --out "${path}${release}-i.zip"
    fi
}

function packFiles {
    if [ ${VERBOSE} -eq 1 ]; then set -x; fi
    zip -9 -r -y -sf ${ignores[@]/#/--exclude=} ${INTERNAL_IGNORE[@]/#/--exclude=} tmp.zip .
    set +x
}

function calculateProcessTime() {
    end=`date +%s`
    runtime=$((end-start))
    echo "Finished for ${runtime} seconds"
}

case "${ARG}" in
    init)
        if [ -d ${PROJECT_DEPY_DIR} ]; then
            error "Depy is already initialized in this directory"
            exit 1
        fi

        cp -R ${DEPY_DIR}/config ${PROJECT_DEPY_DIR}

        success "Done"
    ;;

    setup)
        loadConfigForServer

        if [ -z $(remoteCmdRaw "which unzip") ]; then
            error "Server ${TARGET} does not have unzip installed"
            exit 1
        fi

        if [ ! -z $(remoteCmdRaw "[ ! -w \"${SERVER_CWD}\" ] && echo 1") ]; then
            error "User ${SERVER_USER} does not have write access to directory ${SERVER_CWD}"
            exit 1
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${SERVER_CWD}/releases\" ] && echo 1") ]; then
            remoteCmd "mkdir releases"
        fi
        if [ -z $(remoteCmdRaw "[ -d \"${SERVER_CWD}/shared\" ] && echo 1") ]; then
            remoteCmd "mkdir shared"
        fi
        if [ -z $(remoteCmdRaw "[ -L \"${SERVER_CWD}/current\" ] && echo 1") ]; then
            remoteCmd "ln -s /dev/null current"
        fi

        calculateProcessTime

        success "Done"
    ;;

    deploy)
        loadConfigForServer

        failed=0
        remoteHooksFailed=0
        release=$(releaseName)

        rsyncProgress=$(if [ ${VERBOSE} -eq 1 ]; then echo "--progress"; fi)
        unzipQuiet=$(if [ ${VERBOSE} -ne 1 ]; then echo "-q"; fi)

        # Make sure tmp directory exists
        #
        if [ ! -d ${PROJECT_DEPY_DIR}/tmp ]; then
            mkdir ${PROJECT_DEPY_DIR}/tmp
            echo '*' > ${PROJECT_DEPY_DIR}/tmp
            echo '!.gitignore' >> ${PROJECT_DEPY_DIR}/tmp
        fi

        # Run pre hooks
        #
        set +e
        echo "[local] Running pre hooks"
        for hook in "${pre_hooks[@]}"; do
            runHook ${hook} ${release}
            if [ $? -ne 0 ]; then
                error "[local][${hook}] Finished with error exit code"
                failed=1
                break
            fi
        done
        set -e

        # Remote server work
        #
        if [ ${failed} -eq 0 ]; then
            cwd=${SERVER_CWD}
            server_dns=${SERVER_USER}@${SERVER_HOST}
            server_releases_dir=${SERVER_CWD}/releases/
            server_release_dir=${server_releases_dir}${release}

            if [ ${INCREMENTAL} -eq 1 ]; then
                latestRelease=$(ls -1r ${PROJECT_DEPY_DIR}/tmp | head -1 | sed -E 's/(.*)\.zip/\1/')
            fi

            if [ -z "${latestRelease}" ]; then
                if [ ${INCREMENTAL} -eq 1 ]; then
                    echo "[${TARGET}] No previous release found. Proceeding as full deploy"
                fi

                echo "[local] Packing files"
                pack ${release} ${PROJECT_DEPY_DIR}/tmp

                echo "[local] Transferring packed files"
                rsync --archive ${rsyncProgress} "${PROJECT_DEPY_DIR}/tmp/${release}.zip" -e "ssh -p ${SERVER_PORT} -i ${SERVER_IDENTITY}" \
                    ${server_dns}:${server_releases_dir}

                echo "[${TARGET}] Unpacking files"
                remoteCmd "unzip ${unzipQuiet} \"releases/${release}.zip\" -d \"releases/${release}\"; rm \"releases/${release}.zip\""
            else
                echo "[local] Packing files for incremental deploy"
                pack ${release} ${PROJECT_DEPY_DIR}/tmp ${latestRelease}

                if ! zipinfo "${PROJECT_DEPY_DIR}/tmp/${release}-i.zip" > /dev/null; then
                    echo "[local] Incremental release pack is empty (no changes)"
                    rm "${PROJECT_DEPY_DIR}/tmp/${release}-i.zip"
                    exit 0
                fi

                # Make full release pack of the current files
                # so it can be compated with the next incremental release
                #
                pack ${release} ${PROJECT_DEPY_DIR}/tmp

                echo "[${TARGET}] Preparing for incremental deploy"
                remoteCmd "cp -R ${server_releases_dir}${latestRelease} ${server_release_dir}"

                echo "[local] Transferring packed files"
                rsync --archive ${rsyncProgress} "${PROJECT_DEPY_DIR}/tmp/${release}-i.zip" -e "ssh -p ${SERVER_PORT} -i ${SERVER_IDENTITY}" \
                    ${server_dns}:${server_releases_dir}
                rm "${PROJECT_DEPY_DIR}/tmp/${release}-i.zip"

                echo "[${TARGET}] Unpacking files"
                remoteCmd "unzip -o ${unzipQuiet} \"releases/${release}-i.zip\" -d \"releases/${release}\"; rm \"releases/${release}-i.zip\""
            fi

            # Setup shared files and folders
            #
            for dir in "${shared[@]}"; do
                if [ -d "${dir}" ] || [ -f "${dir}" ]; then
                    if [ -z $(remoteCmdRaw "[ -d \"${SERVER_CWD}/shared/${dir}\" ] && echo 1") ]; then
                        remoteCmd "mv \"releases/${release}/${dir}\" \"shared/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    else
                        remoteCmd "rm -rf \"releases/${release}/${dir}\"; ln -s \"../../shared/${dir}\" \"releases/${release}/${dir}\""
                    fi
                fi
            done

            # Run remote hooks
            #
            set +e
            echo "[${TARGET}] Running remote hooks"
            for hook in "${remote_hooks[@]}"; do
                remoteCmd ${hook} ${server_release_dir}
                if [ $? -ne 0 ]; then
                    error "[${TARGET}][${hook}] Finished with error exit code"
                    failed=1
                    remoteHooksFailed=1
                    break
                fi
            done
            set -e
        fi

        # Skip if any of the pre or remote hooks failed
        #
        if [ ${failed} -eq 0 ]; then
            echo "[${TARGET}] Linking release as current"
            link "${release}"
        fi

        # Clean up old releases or remove failed release
        #
        if [ ${remoteHooksFailed} -eq 0 ]; then
            echo "[${TARGET}] Clean up old releases"
            remoteCmd "cd ${SERVER_CWD}/releases; ls | sort -r | sed '1,${keep_releases}d' | xargs rm -rf --"
        else
            echo "[${TARGET}] Remove failed release"
            remoteCmd "cd ${SERVER_CWD}/releases; ls | sort | tail -n 1 | xargs rm -rf --"
        fi

        # Run post hooks
        #
        set +e
        echo "[local] Running post hooks"
        for hook in "${post_hooks[@]}"; do
            runHook ${hook} ${release}
            if [ $? -ne 0 ]; then
                error "[local][${hook}] Finished with error exit code"
                failed=1
            fi
        done
        set -e

        # Cleaning up local release packages
        #
        echo "[local] Cleaning up local release packages"
        if [ ${VERBOSE} -eq 1 ]; then set -x; fi
        cd ${PROJECT_DEPY_DIR}/tmp
        ls | sort -r | tail -n +2 | xargs rm -rf --
        set +x

        calculateProcessTime

        # Announce result of the operation
        #
        echo
        if [ ${failed} -eq 0 ] && [ $? -eq 0 ]; then
            successBig "Success"
        else
            errorBig "Failure"
        fi
        echo
    ;;

    releases)
        loadConfigForServer

        remoteCmdRaw "cd ${SERVER_CWD}; ls releases"
    ;;

    rollback)
        loadConfigForServer

        release=$3

        if [ ! -z $(remoteCmdRaw "[ -d \"${SERVER_CWD}/releases/${release}\" ] && echo 1") ]; then
            echo "[${TARGET}] Linking release ${release} as current"
            link "${release}"
        else
            error "[${TARGET}] Release ${release} not found"
        fi
    ;;

    pack)
        loadConfig
        pack
        calculateProcessTime
    ;;

    pack-list)
        loadConfig
        packFiles
    ;;

    update)
        cd ${DEPY_DIR}
        git fetch --tags

        if [ ${DEV} -eq 1 ]; then
            tag="master"
        elif [ ${BETA} -eq 1 ]; then
            tag=$(git tag | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | tail -1)
        else
            tag=$(git tag | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | grep -v "rc" | grep -v "alpha" | grep -v "beta" | tail -1)
        fi

        git checkout ${tag} -q
        success "Switched to version \"${tag}\""
    ;;

    *)
        showHelp
    ;;
esac
